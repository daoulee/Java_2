# 📘 4월 10일 (5주차) 자바 수업

---

## 1️⃣ 자바의 예외 클래스

> 자바는 프로그램 실행 중 발생할 수 있는 오류들을 **클래스 형태의 예외(Exception) 객체**로 제공함.  
> 마치 "오류가 났다"는 걸 **편지로 보내주는 예외 객체**로 생각하면 이해 쉬움!

| 예외 타입 (클래스)              | 예외 발생 상황                                                                  | 패키지      |
|-------------------------------|----------------------------------------------------------------------------------|-------------|
| `ArithmeticException`         | 정수를 0으로 나눌 때 발생                                                       | `java.lang` |
| `NullPointerException`        | `null` 레퍼런스를 참조할 때 발생                                                | `java.lang` |
| `ClassCastException`          | 변환할 수 없는 타입으로 객체를 캐스팅할 때 발생                                 | `java.lang` |
| `OutOfMemoryError`            | 메모리가 부족할 때 발생                                                        | `java.lang` |
| `ArrayIndexOutOfBoundsException` | 배열 범위를 벗어난 인덱스에 접근할 때 발생                                | `java.lang` |
| `IllegalArgumentException`    | 잘못된 인자를 메서드에 전달할 때 발생                                          | `java.lang` |
| `IOException`                 | 입출력 도중 실패하거나 인터럽트 되었을 때 발생                                 | `java.io`   |
| `NumberFormatException`       | 숫자로 바꿀 수 없는 문자열을 숫자로 바꾸려 할 때 발생                          | `java.lang` |
| `InputMismatchException`      | `Scanner.nextInt()` 호출 시 문자를 숫자로 바꾸려 할 때 (예: "a" 입력 시)       | `java.util` |

---

## 2️⃣ 예외 클래스 사례 – `ArrayIndexOutOfBoundsException`

> 배열의 범위를 벗어난 인덱스에 접근할 때 발생하는 예외  
> 마치 **택배를 보낼 때 존재하지 않는 주소를 적은 것과 같은 상황!**

## 4️⃣ 자바의 객체 지향 특성: 캡슐화 (Encapsulation)

> 캡슐화란, **객체를 캡슐로 싸서 내부를 숨기고 보호하는 것**  
> 마치 약이 겉껍질에 싸여 있어서 **외부에서 성분을 직접 만지지 못하게 막는 것**과 같음!

### ✅ 캡슐화의 특징

- 객체의 **가장 본질적인 특징**
- 외부로부터 내부 구조를 숨기고 **접근을 제한함**
- 객체 간의 **정보 은닉**을 통해 안정성 향상

---

### 🧪 자바에서의 캡슐화 구현

- **클래스(class)**: 객체의 틀(설계도), 내부 속성과 기능을 선언
- **객체(instance)**: 클래스를 통해 실제로 만들어진 실체

> **TV, 자판기, 카메라, 사람**처럼 복잡한 내부 구조가 외부에 드러나지 않도록 감싸진 구조를 시각적으로 표현함.

- TV나 자판기처럼, **내부 회로는 숨기고 기능만 외부에 제공**함
- 자바의 객체도 마찬가지로, **클래스 내부의 데이터(필드)는 숨기고 메서드로만 접근하도록 구성**하는 것이 캡슐화의 핵심

> 📦 정리하자면, 캡슐화란 "사용자는 겉만 보게 하고, 속은 건드리지 못하게 만드는 구조"  
> (예: 약은 겉 포장만 보고 삼키지만, 내부 성분은 직접 못 만짐)

## 5️⃣ 자바의 객체 지향 특성: 상속 (Inheritance)

> 상속은 **기존 객체(부모)의 속성과 기능을 새로운 객체(자식)가 물려받는 것**  
> 마치 부모님에게 유전자를 물려받듯이, 자식 클래스는 부모 클래스의 필드와 메서드를 그대로 사용할 수 있음.

### ✅ 상속의 특징

- 상위 객체의 **속성이 하위 객체에 전달**됨
- 하위 객체는 **상위 객체의 모든 속성을 가지는 관계**
- 코드 재사용과 유지보수에 효과적임

---

### 🌿 실세계 상속 사례

- **나무**는 식물의 특성과 생물의 특성을 모두 가짐
- **사람**은 생물의 특성만 가지며, 식물의 특성은 없음

```plaintext
생물
├── 동물
│   ├── 어류
│   └── 사람
└── 식물
    ├── 나무
    └── 풀
```


# 7️⃣ 자바의 객체 지향 특성: 다형성 (Polymorphism)

> 다형성이란, **같은 이름의 메서드가 클래스나 객체에 따라 다르게 동작하는 성질**  
> 예: `speak()`라는 메서드를 부르면 **강아지는 "멍멍"**, **고양이는 "야옹"**, **새는 "삐약"** 울음소리가 다르게 나옴.

---

### 📌 다형성의 구현 방식

1. **메서드 오버로딩 (Overloading)**  
   - 한 클래스 내에서 **같은 이름의 메서드가 매개변수에 따라 여러 버전으로 정의**
   - 예: `print(int x)`, `print(String s)`

2. **메서드 오버라이딩 (Overriding)**  
   - **슈퍼 클래스의 메서드를 서브 클래스에서 재정의**해서 동작을 다르게 만듦
   - 예: `Animal` 클래스의 `speak()`를 `Dog`, `Cat`, `Bird` 클래스가 각각 다르게 구현

## 8️⃣ 객체 지향 언어의 목적

### 🎯 1. 소프트웨어의 생산성 향상

> 컴퓨터 산업이 발전하면서, **소프트웨어의 수명 주기(life cycle)**는 짧아지고  
> 새로운 프로그램을 빠르게 개발해야 할 필요성이 커짐

---

### 📌 객체 지향 언어의 역할

- **상속, 다형성, 객체, 캡슐화** 등의 개념을 통해  
  소프트웨어 구성 요소를 **재사용**하고, 유지보수를 **더 쉽고 빠르게** 함
- 기존 코드를 **수정하거나 확장**하는 게 쉬워짐
- 소프트웨어를 **처음부터 다시 만드는 부담 감소**
- 결과적으로 **개발 속도 향상 → 생산성 향상**

> 🔁 비유하자면, 객체 지향은 마치 **레고 블록처럼 조립하는 프로그래밍**  
> 이미 만들어둔 블록(객체)을 조합해서 빠르게 새로운 구조를 만드는 느낌!

## 객체 지향 언어의 목적

### 2. 실세계에 대한 쉬운 모델링

#### 🔹 초기 프로그래밍

- 수학 계산/통계 처리 등 **처리 과정과 계산 절차가 중요**했던 시기
- 프로그램은 주로 "절차 중심"으로 구성되었음

#### 🔹 현대 프로그래밍

- 컴퓨터가 산업 전반에 활용되면서 실세계의 문제를 다루기 시작
- 실세계에서 발생하는 다양한 상황을 프로그램으로 표현하려는 시도
- 이때부터는 단순한 계산보다 **실제 세상의 "물체(객체)"들이 상호작용**하는 방식을 모델링하기 시작

#### 🔹 객체 지향 언어의 등장

- 실세계의 일을 더 쉽게 표현하고 구현하기 위해, **"객체 중심" 프로그래밍 언어**가 등장
- 예를 들어, **자동차, 사람, 계좌** 같은 실생활의 대상들을 **객체**로 만들어 코드로 표현함  
  → 마치 우리가 **레고 블럭**을 조립하듯, 객체들을 조합해 복잡한 프로그램을 만드는 방식

---

### 🔹 객체 지향 프로그래밍 (Object-Oriented Programming)

- 프로그램을 **객체들 간의 상호작용**으로 구성
- **클래스 또는 객체들의 집합**으로 프로그램을 설계
- 각 객체는 **자신의 역할과 책임**을 가짐
- 예: 커피 자판기를 구성하는 다양한 부품(객체)들이  
  각각 기능을 수행하고, 상호작용함

  ## 클래스(Class)와 객체(Object)

### 🔹 클래스란?

- 객체의 **속성(state)**과 **행위(behavior)**를 선언한 설계도
- 쉽게 말해, **객체를 찍어내기 위한 틀** 혹은 도면이라고 할 수 있음

🛠 비유:
> 클래스는 **붕어빵 틀**, 객체는 그 틀로 구운 **붕어빵**  
> 붕어빵 틀(클래스)은 하나지만, 여러 개의 붕어빵(객체)을 만들 수 있음

---

### 🔹 객체란?

- 클래스라는 틀에서 **실제로 찍어낸 실체**
- 프로그램이 **실행되는 동안 메모리에 생성**되는 것
- **구체적인 메모리 공간을 가지는 존재**
- 객체는 보통 **인스턴스(instance)**라고도 부름

---

### 🔹 예시

## 클래스(Class)와 객체(Object)의 쉬운 비유

클래스는 객체를 만들기 위한 **설계도**,  
객체는 그 설계도로부터 **만들어진 실체**

---

### ex: 아이폰과 내 아이폰

| 개념     | 설명                                                     |
|----------|----------------------------------------------------------|
| 클래스   | 아이폰 14의 제조 설계도                                   |
| 객체     | 내가 쓰는 아이폰 14 (저장된 사진, 설정 등은 각각 다름)     |

---

📝 정리:  
**클래스는 설명서📘, 객체는 설명서대로 만들어진 물건📦**

## 생성자(Constructor)의 개념과 목적

생성자는 객체가 **생성될 때 자동으로 실행되는 메소드**로,  
주로 **객체를 초기화**하는 데 사용됩니다.

---

### 🧠 생성자의 특징

- 클래스 이름과 동일한 이름을 가짐
- 반환 타입이 없음 (`void`조차도 안 붙임!)
- 객체가 **생성되는 순간 자동 호출됨**
- 보통 객체의 **필드 초기화**에 사용됨

---

### 💄 비유: "객체 메이크오버"

| 단계             | 설명                                      |
|------------------|-------------------------------------------|
| 기본 객체        | 아직 아무런 값도 설정되지 않은 상태        |
| 생성자 실행      | 값들을 설정해주는 메이크업 과정            |
| 초기화된 객체    | 이름, 속성 등이 채워져 실제로 쓸 수 있는 상태 |

→ 마치 사람이 미용실 가서 스타일링 받고 나오는 느낌!

---
## 생성자의 특징

자바에서 생성자는 **객체가 생성될 때 단 한 번 자동으로 호출되는 메소드**이며, 객체의 필드 값을 초기화하는 데 사용됩니다. 생성자의 이름은 반드시 클래스 이름과 같아야 하고, **반환 타입은 절대 가질 수 없습니다**. `void`조차 붙이면 컴파일 오류가 발생합니다. 하나의 클래스 안에는 **여러 개의 생성자**를 정의할 수 있는데, 이를 **생성자 오버로딩**이라 부릅니다. 오버로딩된 생성자들은 매개변수의 수나 타입이 다르며, 객체 생성 시 전달되는 인자에 따라 어떤 생성자가 호출될지가 결정됩니다.

📦 비유하자면, **생성자는 물건이 공장에서 처음 나올 때 부품을 조립하고 포장하는 초기 공정과 같아요.**  
공장에서 같은 물건이라도 옵션에 따라 다르게 조립되듯, 생성자도 전달된 정보에 따라 **초기 상태를 다르게 설정**해줍니다. 그리고 이 과정은 **new 연산자를 통해 객체가 만들어질 때 단 한 번만 자동으로 실행**됩니다.

---

### 🔑 생성자의 주요 특징 정리

- 생성자의 이름은 **클래스 이름과 동일**
- **리턴 타입이 없음** (`void`도 사용 ❌)
- 객체 생성 시 **단 한 번만 자동 호출**
- 객체 생성 시 반드시 `new` 연산자와 함께 사용
- **여러 개 작성 가능** → 매개변수에 따라 다른 생성자 호출됨 (**생성자 오버로딩**)

---

### ✅ 예시: 생성자 오버로딩

```java
public class Circle {
    public Circle() {
        // 기본 생성자
    }

    public Circle(int r, String n) {
        // 매개변수 있는 생성자
    }
}