# R    E    A     D     M       E       양          식 

# 컴퓨터정보학부 2학년 1반 최다울 202230136

## 4월 xx일 (x주차)
### ( 학습 내용 ) , ( 코드 )

# h1 태그
## h2 태그
### h3 태그
#### h4 태그
##### h5 태그
###### h6 태그

## 3월 20일 (3주차)
#### README.md 파일 편집
* ( R E A D . M E 파일 작성법)
* 이름 학번 (h1 크기로 제일 위에 기재 )
* 학습 시기 ( 몇주차인지 )
* 배운 내용 & 코드
* 최근 학습이 제일 위로 최신화


## 4월 3일(4주차)
- ## 반복문
- ## for 문 , while 문 do while 문
- ## 2차원 배열

## 2차원 배열 
- #### ex 2-1반 페이지 , 2-2반 페이지 까지는 2차원 반이 늘어난다고 3차원이아님.
- #### 아예 다른 페이지일 경우 3차원
# 2차원 배열 예시
- #### 사용 상황: 
학생들의 시험 점수를 저장하고 출력하는 경우 (행은 학생, 열은 과목).

$ public class TwoDimensionalArray {

    public static void main(String[] args) {

        int[][] scores = {
            {85, 90, 92}, // 학생 1의 점
            (국어, 수학, 영어)
            {78, 88, 91}, // 학생 2의 점수
            {90, 77, 89}  // 학생 3의 점수
        };

        System.out.println("학생 1의 수학 점수: " + scores[0][1]); // 출력: 90
        System.out.println("학생 2의 영어 점수: " + scores[1][2]); // 출력: 91
    }
}
#
# 📘 4월 10일 (5주차) 자바 수업

---

## 1️⃣ 자바의 예외 클래스

> 자바는 프로그램 실행 중 발생할 수 있는 오류들을 **클래스 형태의 예외(Exception) 객체**로 제공함.  
> 마치 "오류가 났다"는 걸 **편지로 보내주는 예외 객체**로 생각하면 이해 쉬움!

| 예외 타입 (클래스)              | 예외 발생 상황                                                                  | 패키지      |
|-------------------------------|----------------------------------------------------------------------------------|-------------|
| `ArithmeticException`         | 정수를 0으로 나눌 때 발생                                                       | `java.lang` |
| `NullPointerException`        | `null` 레퍼런스를 참조할 때 발생                                                | `java.lang` |
| `ClassCastException`          | 변환할 수 없는 타입으로 객체를 캐스팅할 때 발생                                 | `java.lang` |
| `OutOfMemoryError`            | 메모리가 부족할 때 발생                                                        | `java.lang` |
| `ArrayIndexOutOfBoundsException` | 배열 범위를 벗어난 인덱스에 접근할 때 발생                                | `java.lang` |
| `IllegalArgumentException`    | 잘못된 인자를 메서드에 전달할 때 발생                                          | `java.lang` |
| `IOException`                 | 입출력 도중 실패하거나 인터럽트 되었을 때 발생                                 | `java.io`   |
| `NumberFormatException`       | 숫자로 바꿀 수 없는 문자열을 숫자로 바꾸려 할 때 발생                          | `java.lang` |
| `InputMismatchException`      | `Scanner.nextInt()` 호출 시 문자를 숫자로 바꾸려 할 때 (예: "a" 입력 시)       | `java.util` |

---

## 2️⃣ 예외 클래스 사례 – `ArrayIndexOutOfBoundsException`

> 배열의 범위를 벗어난 인덱스에 접근할 때 발생하는 예외  
> 마치 **택배를 보낼 때 존재하지 않는 주소를 적은 것과 같은 상황!**

## 4️⃣ 자바의 객체 지향 특성: 캡슐화 (Encapsulation)

> 캡슐화란, **객체를 캡슐로 싸서 내부를 숨기고 보호하는 것**  
> 마치 약이 겉껍질에 싸여 있어서 **외부에서 성분을 직접 만지지 못하게 막는 것**과 같음!

### ✅ 캡슐화의 특징

- 객체의 **가장 본질적인 특징**
- 외부로부터 내부 구조를 숨기고 **접근을 제한함**
- 객체 간의 **정보 은닉**을 통해 안정성 향상

---

### 🧪 자바에서의 캡슐화 구현

- **클래스(class)**: 객체의 틀(설계도), 내부 속성과 기능을 선언
- **객체(instance)**: 클래스를 통해 실제로 만들어진 실체

> **TV, 자판기, 카메라, 사람**처럼 복잡한 내부 구조가 외부에 드러나지 않도록 감싸진 구조를 시각적으로 표현함.

- TV나 자판기처럼, **내부 회로는 숨기고 기능만 외부에 제공**함
- 자바의 객체도 마찬가지로, **클래스 내부의 데이터(필드)는 숨기고 메서드로만 접근하도록 구성**하는 것이 캡슐화의 핵심

> 📦 정리하자면, 캡슐화란 "사용자는 겉만 보게 하고, 속은 건드리지 못하게 만드는 구조"  
> (예: 약은 겉 포장만 보고 삼키지만, 내부 성분은 직접 못 만짐)

## 5️⃣ 자바의 객체 지향 특성: 상속 (Inheritance)

> 상속은 **기존 객체(부모)의 속성과 기능을 새로운 객체(자식)가 물려받는 것**  
> 마치 부모님에게 유전자를 물려받듯이, 자식 클래스는 부모 클래스의 필드와 메서드를 그대로 사용할 수 있음.

### ✅ 상속의 특징

- 상위 객체의 **속성이 하위 객체에 전달**됨
- 하위 객체는 **상위 객체의 모든 속성을 가지는 관계**
- 코드 재사용과 유지보수에 효과적임

---

### 🌿 실세계 상속 사례

- **나무**는 식물의 특성과 생물의 특성을 모두 가짐
- **사람**은 생물의 특성만 가지며, 식물의 특성은 없음

```plaintext
생물
├── 동물
│   ├── 어류
│   └── 사람
└── 식물
    ├── 나무
    └── 풀
```


# 7️⃣ 자바의 객체 지향 특성: 다형성 (Polymorphism)

> 다형성이란, **같은 이름의 메서드가 클래스나 객체에 따라 다르게 동작하는 성질**  
> 예: `speak()`라는 메서드를 부르면 **강아지는 "멍멍"**, **고양이는 "야옹"**, **새는 "삐약"** 울음소리가 다르게 나옴.

---

### 📌 다형성의 구현 방식

1. **메서드 오버로딩 (Overloading)**  
   - 한 클래스 내에서 **같은 이름의 메서드가 매개변수에 따라 여러 버전으로 정의**
   - 예: `print(int x)`, `print(String s)`

2. **메서드 오버라이딩 (Overriding)**  
   - **슈퍼 클래스의 메서드를 서브 클래스에서 재정의**해서 동작을 다르게 만듦
   - 예: `Animal` 클래스의 `speak()`를 `Dog`, `Cat`, `Bird` 클래스가 각각 다르게 구현

## 8️⃣ 객체 지향 언어의 목적

### 🎯 1. 소프트웨어의 생산성 향상

> 컴퓨터 산업이 발전하면서, **소프트웨어의 수명 주기(life cycle)**는 짧아지고  
> 새로운 프로그램을 빠르게 개발해야 할 필요성이 커짐

---

### 📌 객체 지향 언어의 역할

- **상속, 다형성, 객체, 캡슐화** 등의 개념을 통해  
  소프트웨어 구성 요소를 **재사용**하고, 유지보수를 **더 쉽고 빠르게** 함
- 기존 코드를 **수정하거나 확장**하는 게 쉬워짐
- 소프트웨어를 **처음부터 다시 만드는 부담 감소**
- 결과적으로 **개발 속도 향상 → 생산성 향상**

> 🔁 비유하자면, 객체 지향은 마치 **레고 블록처럼 조립하는 프로그래밍**  
> 이미 만들어둔 블록(객체)을 조합해서 빠르게 새로운 구조를 만드는 느낌!

## 객체 지향 언어의 목적

### 2. 실세계에 대한 쉬운 모델링

#### 🔹 초기 프로그래밍

- 수학 계산/통계 처리 등 **처리 과정과 계산 절차가 중요**했던 시기
- 프로그램은 주로 "절차 중심"으로 구성되었음

#### 🔹 현대 프로그래밍

- 컴퓨터가 산업 전반에 활용되면서 실세계의 문제를 다루기 시작
- 실세계에서 발생하는 다양한 상황을 프로그램으로 표현하려는 시도
- 이때부터는 단순한 계산보다 **실제 세상의 "물체(객체)"들이 상호작용**하는 방식을 모델링하기 시작

#### 🔹 객체 지향 언어의 등장

- 실세계의 일을 더 쉽게 표현하고 구현하기 위해, **"객체 중심" 프로그래밍 언어**가 등장
- 예를 들어, **자동차, 사람, 계좌** 같은 실생활의 대상들을 **객체**로 만들어 코드로 표현함  
  → 마치 우리가 **레고 블럭**을 조립하듯, 객체들을 조합해 복잡한 프로그램을 만드는 방식

---

### 🔹 객체 지향 프로그래밍 (Object-Oriented Programming)

- 프로그램을 **객체들 간의 상호작용**으로 구성
- **클래스 또는 객체들의 집합**으로 프로그램을 설계
- 각 객체는 **자신의 역할과 책임**을 가짐
- 예: 커피 자판기를 구성하는 다양한 부품(객체)들이  
  각각 기능을 수행하고, 상호작용함

  ## 클래스(Class)와 객체(Object)

### 🔹 클래스란?

- 객체의 **속성(state)**과 **행위(behavior)**를 선언한 설계도
- 쉽게 말해, **객체를 찍어내기 위한 틀** 혹은 도면이라고 할 수 있음

🛠 비유:
> 클래스는 **붕어빵 틀**, 객체는 그 틀로 구운 **붕어빵**  
> 붕어빵 틀(클래스)은 하나지만, 여러 개의 붕어빵(객체)을 만들 수 있음

---

### 🔹 객체란?

- 클래스라는 틀에서 **실제로 찍어낸 실체**
- 프로그램이 **실행되는 동안 메모리에 생성**되는 것
- **구체적인 메모리 공간을 가지는 존재**
- 객체는 보통 **인스턴스(instance)**라고도 부름

---

### 🔹 예시

## 클래스(Class)와 객체(Object)의 쉬운 비유

클래스는 객체를 만들기 위한 **설계도**,  
객체는 그 설계도로부터 **만들어진 실체**

---

### ex: 아이폰과 내 아이폰

| 개념     | 설명                                                     |
|----------|----------------------------------------------------------|
| 클래스   | 아이폰 14의 제조 설계도                                   |
| 객체     | 내가 쓰는 아이폰 14 (저장된 사진, 설정 등은 각각 다름)     |

---

📝 정리:  
**클래스는 설명서📘, 객체는 설명서대로 만들어진 물건📦**

## 생성자(Constructor)의 개념과 목적

생성자는 객체가 **생성될 때 자동으로 실행되는 메소드**로,  
주로 **객체를 초기화**하는 데 사용됩니다.

---

### 🧠 생성자의 특징

- 클래스 이름과 동일한 이름을 가짐
- 반환 타입이 없음 (`void`조차도 안 붙임!)
- 객체가 **생성되는 순간 자동 호출됨**
- 보통 객체의 **필드 초기화**에 사용됨

---

### 💄 비유: "객체 메이크오버"

| 단계             | 설명                                      |
|------------------|-------------------------------------------|
| 기본 객체        | 아직 아무런 값도 설정되지 않은 상태        |
| 생성자 실행      | 값들을 설정해주는 메이크업 과정            |
| 초기화된 객체    | 이름, 속성 등이 채워져 실제로 쓸 수 있는 상태 |

→ 마치 사람이 미용실 가서 스타일링 받고 나오는 느낌!

---
## 생성자의 특징

자바에서 생성자는 **객체가 생성될 때 단 한 번 자동으로 호출되는 메소드**이며, 객체의 필드 값을 초기화하는 데 사용됩니다. 생성자의 이름은 반드시 클래스 이름과 같아야 하고, **반환 타입은 절대 가질 수 없습니다**. `void`조차 붙이면 컴파일 오류가 발생합니다. 하나의 클래스 안에는 **여러 개의 생성자**를 정의할 수 있는데, 이를 **생성자 오버로딩**이라 부릅니다. 오버로딩된 생성자들은 매개변수의 수나 타입이 다르며, 객체 생성 시 전달되는 인자에 따라 어떤 생성자가 호출될지가 결정됩니다.

📦 비유하자면, **생성자는 물건이 공장에서 처음 나올 때 부품을 조립하고 포장하는 초기 공정과 같아요.**  
공장에서 같은 물건이라도 옵션에 따라 다르게 조립되듯, 생성자도 전달된 정보에 따라 **초기 상태를 다르게 설정**해줍니다. 그리고 이 과정은 **new 연산자를 통해 객체가 만들어질 때 단 한 번만 자동으로 실행**됩니다.

---

### 🔑 생성자의 주요 특징 정리

- 생성자의 이름은 **클래스 이름과 동일**
- **리턴 타입이 없음** (`void`도 사용 ❌)
- 객체 생성 시 **단 한 번만 자동 호출**
- 객체 생성 시 반드시 `new` 연산자와 함께 사용
- **여러 개 작성 가능** → 매개변수에 따라 다른 생성자 호출됨 (**생성자 오버로딩**)

---

### ✅ 예시: 생성자 오버로딩

```java
public class Circle {
    public Circle() {
        // 기본 생성자
    }

    public Circle(int r, String n) {
        // 매개변수 있는 생성자
    }
}
```


# 📘 4월 17일 자바 수업 정리

---

## 1️⃣ 생성자 – 기본 생성자 (Default Constructor)

- 매개변수가 없고, 내부에서 아무 작업도 하지 않는 생성자
- 생성자를 작성하지 않으면 자바가 자동으로 `클래스명()` 생성자 만들어줌

> 🧠 비유: 옵션 안 고르고 그냥 기본으로 계약한 원룸 느낌

---

## 2️⃣ 생성자가 자동 생성되지 않는 경우

- 생성자를 하나라도 직접 작성하면, 자바는 기본 생성자를 더 이상 자동으로 만들지 않음
- 기본 생성자를 사용하고 싶다면, 반드시 명시적으로 `public 클래스명() {}` 작성해야 함

> 🧠 비유: 내가 원하는 옵션 방을 직접 골랐기 때문에, 자동 기본 옵션 제공은 중단됨

---

## 3️⃣ this 레퍼런스

- `this`는 객체 자기 자신을 참조하는 키워드
- 주로 멤버 변수와 매개변수 이름이 겹칠 때 구분용으로 사용

> 🧠 비유: “내 거야”라고 말할 때의 ‘나’와 같은 느낌

---

## 4️⃣ 객체 안에서의 this

- `this`는 메서드를 호출한 객체를 가리킴
- ob1, ob2, ob3가 각각 `set()`을 호출하면, `this`는 각각 ob1, ob2, ob3를 참조

> 🧠 비유: 학생 세 명이 “내 노트”라고 말하면, 각자 자기 노트를 말하는 것과 같음

---

## 5️⃣ this()로 다른 생성자 호출

- 같은 클래스의 다른 생성자를 호출할 때 사용
- 생성자 안에서만 사용 가능하며, 반드시 **첫 줄**에 위치해야 함

> 🧠 비유: 같은 가게에서 세트 메뉴 하나 먼저 부르고, 거기에 추가로 토핑을 올리는 느낌

---

## 6️⃣ 인자 전달 – 배열이 전달되는 경우

- 배열은 **값이 아닌 참조(레퍼런스)**가 전달됨
- 메서드에서 배열을 변경하면, 원본 배열도 바뀜

> 🧠 비유: 종이 한 장을 복사하는 게 아니라, 같은 종이를 같이 쓰는 것

---

## 7️⃣ 인자 전달 – 객체가 전달되는 경우

- 객체도 배열과 마찬가지로 참조가 전달됨
- 전달된 객체 내부 상태가 변경되면, 호출한 쪽 객체도 함께 바뀜

---

## 8️⃣ 인자 전달 – 기본 타입의 값이 전달되는 경우

- `int`, `double` 등 기본형 타입은 **값 자체**가 복사되어 전달됨
- 메서드 내부에서 변경해도, 원본 값은 바뀌지 않음

> 🧠 비유: 사본을 받은 후 내가 거기 낙서해도, 원본 종이는 그대로인 느낌

---

## 9️⃣ 예제 – 인자로 배열이 전달되는 예

- `char[]` 배열을 전달받아, 공백(' ')을 `','`로 바꾸는 메서드 작성
- 배열을 메서드에 전달하면, 원본 배열도 같이 변경됨

---

## 🔁 메서드 오버로딩 (Overloading)

- 같은 이름의 메서드를 **매개변수의 타입이나 개수**만 다르게 해서 여러 개 정의
- 리턴 타입은 오버로딩과 관계 없음

> 🧠 비유: 같은 가게에서 “주문”이라고 말했지만, 사람마다 메뉴가 다른 경우

---

## 🧱 객체 배열 선언과 생성 과정

### 자바의 객체 배열 만들기 3단계

1. 객체 배열 변수 선언  
   → `Circle[] c;`
2. 배열 공간 확보  
   → `c = new Circle[5];`
3. 배열 각 칸에 실제 객체 생성  
   → `c[i] = new Circle(i);`

---

## 🔧 메서드

- 자바의 함수 = 메서드
- 모든 메서드는 반드시 클래스 내부에 선언되어야 함 (캡슐화 원칙)
- 메서드는 다음과 같은 구성 요소를 가짐:

  - 접근 지정자 (예: `public`)
  - 리턴 타입 (예: `int`)
  - 메서드 이름 (예: `getSum`)
  - 매개변수 목록 (예: `int i, int j`)
  - 본문 코드

---

## 예제 – Circle 배열 만들기

- `Circle` 객체를 5개 생성하고, 각각 반지름 0~4를 넣어 저장
- 이후 배열을 순회하며 각 객체의 면적을 출력함

# 📘 자바 접근 지정자, static 멤버, 가비지 컬렉션 정리

## 멤버 접근 지정자

| 접근 지정자 | 같은 패키지 | 다른 패키지 | 상속 관계 | 설명 |
|-------------|--------------|--------------|------------|------|
| `private`   | ❌           | ❌           | ❌         | 같은 클래스 내부에서만 접근 가능 |
| `default`   | ⭕           | ❌           | ❌         | 같은 패키지 내의 클래스만 접근 가능 |
| `protected` | ⭕           | ❌           | ⭕         | 같은 패키지 + 다른 패키지 자식 클래스도 접근 가능 |
| `public`    | ⭕           | ⭕           | ⭕         | 모든 클래스에서 접근 가능 |

> 📌 비유:  
> `private`는 **집 비밀번호**,  
> `default`는 **우리 아파트 주민 전용**,  
> `protected`는 **친척들까지 들어올 수 있음**,  
> `public`은 **누구든 환영하는 오픈 행사** 느낌이야!

---

## 클래스 접근 지정자

- `public` 클래스: 모든 패키지에서 접근 가능  
- `default` 클래스: 같은 패키지에서만 접근 가능  

> 🏠 비유:  
> `public class`는 누구나 들어올 수 있는 **오픈 카페**,  
> `default class`는 아파트 **입주민 전용 커뮤니티 센터**!

---

## 접근 지정자의 목적

- **객체지향의 캡슐화** 원칙을 지키기 위해 멤버 접근을 제어함
- 정보를 숨기고 필요한 것만 외부에 공개하도록 함

> 🔐 비유:  
> 클래스는 **비밀 금고**,  
> 접근 지정자는 **열쇠 권한**을 관리하는 느낌!

---

##  자바의 패키지 개념

- 관련된 클래스들을 묶는 **폴더(디렉토리)**
- 하나의 자바 응용프로그램은 여러 개의 패키지로 구성됨

> 📦 비유:  
> 패키지는 **문서철 폴더**,  
> 클래스는 그 안에 있는 **문서 한 장**이야!

---

## 가비지 컬렉션 개념

- JVM이 **사용하지 않는 객체(가비지)**를 자동으로 회수함
- `System.gc()` 또는 `Runtime.getRuntime().gc()`로 수동 요청 가능

> 🧹 비유:  
> 안 쓰는 변수는 **쓰레기**,  
> 가비지 컬렉터는 **청소부**!

---

## 가비지 발생 예시

```java
String a = new String("Good");
a = null; // "Good"은 가비지 발생



Person a = new Person("홍길동");
Person b = new Person("이몽룡");
b = a; // 이전 b가 가리키던 객체는 가비지

🪙 비유:
b가 새 장난감을 사면서 예전 장난감은 버림받은 상태!
```
# 📘 자바 접근 지정자, static 멤버, 가비지 컬렉션 정리

## 멤버 접근 지정자

| 접근 지정자 | 같은 패키지 | 다른 패키지 | 상속 관계 | 설명 |
|-------------|--------------|--------------|------------|------|
| `private`   | ❌           | ❌           | ❌         | 같은 클래스 내부에서만 접근 가능 |
| `default`   | ⭕           | ❌           | ❌         | 같은 패키지 내의 클래스만 접근 가능 |
| `protected` | ⭕           | ❌           | ⭕         | 같은 패키지 + 다른 패키지 자식 클래스도 접근 가능 |
| `public`    | ⭕           | ⭕           | ⭕         | 모든 클래스에서 접근 가능 |

> 📌 비유:  
> `private`는 **집 비밀번호**,  
> `default`는 **우리 아파트 주민 전용**,  
> `protected`는 **친척들까지 들어올 수 있음**,  
> `public`은 **누구든 환영하는 오픈 행사** 느낌이야!

---

## 클래스 접근 지정자

- `public` 클래스: 모든 패키지에서 접근 가능  
- `default` 클래스: 같은 패키지에서만 접근 가능  

> 🏠 비유:  
> `public class`는 누구나 들어올 수 있는 **오픈 카페**,  
> `default class`는 아파트 **입주민 전용 커뮤니티 센터**!

---

## 접근 지정자의 목적

- **객체지향의 캡슐화** 원칙을 지키기 위해 멤버 접근을 제어함
- 정보를 숨기고 필요한 것만 외부에 공개하도록 함

> 🔐 비유:  
> 클래스는 **비밀 금고**,  
> 접근 지정자는 **열쇠 권한**을 관리하는 느낌!

---

## 자바의 패키지 개념

- 관련된 클래스들을 묶는 **폴더(디렉토리)**
- 하나의 자바 응용프로그램은 여러 개의 패키지로 구성됨

> 📦 비유:  
> 패키지는 **문서철 폴더**,  
> 클래스는 그 안에 있는 **문서 한 장**이야!

---

## 가비지 컬렉션 개념

- JVM이 **사용하지 않는 객체(가비지)**를 자동으로 회수함
- `System.gc()` 또는 `Runtime.getRuntime().gc()`로 수동 요청 가능

> 🧹 비유:  
> 안 쓰는 변수는 **쓰레기**,  
> 가비지 컬렉터는 **청소부**!

---

##  가비지 발생 예시

```java
String a = new String("Good");
a = null; // "Good"은 가비지 발생
```

> 참조가 사라지는 순간, 힙 메모리 안의 객체는 가비지!

---

## 가비지 예제 (레퍼런스 교체)

```java
Person a = new Person("홍길동");
Person b = new Person("이몽룡");
b = a; // 이전 b가 가리키던 객체는 가비지
```

> 🪙 비유:  
> b가 새 장난감을 사면서 예전 장난감은 **버림받은 상태**!

---

## 객체 소멸 개념

- `new`로 만든 객체는 **JVM의 힙**에 저장됨
- 더 이상 사용하지 않으면 GC가 회수

> 🚮 자바는 쓰레기 버리는 걸 **직접 안 해도 되는 편리함**이 있어

---

## 객체 치환 시 주의

```java
ob1 = ob2; // ob1이 가리키던 객체는 더 이상 접근 불가 → 가비지
```

> 🎯 복사는 내용이 아니라 **참조(화살표)**가 바뀌는 거야!

---

## 오버로딩 실패 예시

```java
public int getSum(int i, int j) { ... }
public double getSum(int i, int j) { ... } // ❌ 실패
```

> ⚠️ 매개변수의 개수나 타입이 달라야 오버로딩 성공!

---

## static 메서드 예제

```java
public class Calc {
    public static int abs(int a) { return a > 0 ? a : -a; }
    public static int max(int a, int b) { return a > b ? a : b; }
    public static int min(int a, int b) { return a > b ? b : a; }
}
```

> 🧮 전역 유틸 클래스의 대표적인 예: `Math.abs()`, `Math.max()` 처럼 사용!

---

## static 메서드 제약 조건

- static 메서드는 **static 멤버만 접근 가능**
- 객체 생성 없이 실행되므로 non-static 멤버는 사용 불가

> 🧱 비유:  
> 건물 설계도만 있는 상태에선 **내부 가구 배치(객체 멤버)**는 접근 불가!

---

## static의 활용

- **전역 변수 / 전역 함수** 느낌
- **공통 속성 또는 기능** 정의 시 사용

---

## static 멤버 생성

- 클래스당 **하나만 생성됨**
- 모든 객체가 공유

> 👥 비유:  
> 학교 전체가 공유하는 **학칙**,  
> 반마다 있는 건 아님!

---


## static 멤버 사용 방법

- 클래스 이름으로 직접 접근
```java
StaticSample.m = 5;
StaticSample.f();
```
- 객체 이름으로도 접근 가능
```java
obj.m = 5;
obj.f();
```

---

## non-static 멤버 접근 불가 예시

```java
StaticSample.n = 5; // ❌ 오류
StaticSample.g();   // ❌ 오류
```

> ❗ 객체가 생성되어야 사용할 수 있음!

---

## static vs non-static 차이

| 특성 | non-static | static |
|------|------------|--------|
| 생성 시점 | 객체 생성 시 | 클래스 로딩 시 |
| 생성 수 | 객체마다 별도 | 클래스당 1개 |
| 메모리 위치 | 힙 영역 | 메서드 영역 |
| 공유 여부 | ❌ | ⭕ |

---

## static 멤버는 언제 생성?

- 객체 없이도 생성됨  
- 모든 객체가 같은 static 멤버를 공유

---

##  static 멤버 선언 예시

```java
class StaticSample {
    static int m;
    static void f() { ... }
}
```

---

## 접근 지정자 예제

```java
class Sample {
    public int a;
    private int b;
    int c; // default
}

public class AccessEx {
    public static void main(String[] args) {
        Sample s = new Sample();
        s.a = 10; // ⭕
        s.b = 10; // ❌ private
        s.c = 10; // ⭕ default (같은 패키지)
    }
}
```


