# 📘 2025년 4월 17일 자바 수업 정리

---

## ✅ 생성자의 종류

- 생성자는 객체를 만들 때 자동으로 호출되어 **객체를 초기화**하는 메서드다.
- **클래스 이름과 동일한 이름을 가지며, 반환 타입이 없다 (void도 사용 ❌)**

### 🛠 기본 생성자 (Default Constructor)

- 매개변수가 없고, 아무 작업도 하지 않는 단순한 생성자
- 클래스에 생성자가 아무것도 선언되어 있지 않으면 **컴파일러가 자동으로 생성**해준다

> 🔧 비유 : 공장에서 물건을 만들 때, 옵션 없이 **기본 구성으로 출고**되는 느낌

### ❗ 기본 생성자가 자동 생성되지 않는 경우

- 사용자가 직접 다른 생성자를 작성한 경우, 기본 생성자는 **자동으로 생성되지 않음**
- 이 경우 기본 생성자를 **명시적으로 정의해야 함**

> ⚠️ 비유 : 고객이 “특수 옵션”을 요구해서 공장에서 기본 옵션을 **자동으로 생략한 상황**

---

## ✅ 객체 속에서의 this

- `this`는 **자기 자신 객체를 가리키는 참조 변수**
- 필드 이름과 매개변수 이름이 겹칠 때 사용하여 **구분**해준다

> 🙋 비유 : "나 자신을 가리키는 말" — 같은 반에 ‘영수’가 둘일 때, “이 영수요!” 하고 **자기 자신을 가리키는 느낌**

---

## ✅ this 레퍼런스

- 객체 자기 자신에 대한 참조값을 가지고 있음
- **컴파일러가 자동으로 처리**, 개발자가 직접 선언하지 않아도 된다
- `this.변수` 형태로 **객체 내 필드에 접근**할 때 주로 사용됨

> 📦 비유 : 택배 상자 안에 “이 상자 안에 든 물건”이라고 라벨링 해두는 느낌

---

## ✅ 생성자에서의 this()

- 하나의 생성자에서 **다른 생성자를 호출**할 때 사용 (`this(...)`)
- 반드시 **생성자 내부 첫 줄에 위치해야 함**
- 생성자 코드 중복을 줄일 수 있음

> 🔁 비유 : 레시피 A를 만들기 위해 레시피 B를 **먼저 실행한 후**에 A를 계속하는 느낌  
> (예: “먼저 반죽 만들기(this), 그 후에 굽기”)

---

## ❌ this() 사용 실패 예

- `this()`는 생성자 내부에서만 사용 가능
- 일반 메서드에서는 사용할 수 없음
- 생성자 호출은 **무조건 첫 줄에 와야 함**, 다른 문장이 먼저 오면 컴파일 에러

---

## ✅ 멤버의 접근 지정자

- 접근 지정자는 **클래스의 멤버(변수/메서드)의 접근 범위를 지정**한다

| 지정자      | 접근 가능 범위 |
|-------------|----------------|
| `public`    | 모든 클래스에서 접근 가능 |
| (default)   | 같은 패키지 내 클래스만 접근 가능 |
| `private`   | 같은 클래스 내에서만 접근 가능 |

> 🔒 비유 :  
> - `public` = 누구나 출입 가능한 공공장소  
> - `default` = 회사 출입증 있는 사람만 들어갈 수 있는 구역  
> - `private` = 집 안방처럼 본인만 들어갈 수 있음

---

## ✅ 배열을 인자로 전달할 때 (배열 참조 전달)

- 자바에서는 배열을 메서드에 전달할 때 **배열의 참조(주소)**가 전달됨
- 메서드 안에서 배열 내용을 바꾸면 **원래 배열에도 영향을 줌**

> 📬 비유 : 편지를 복사해서 주는 게 아니라, **원본 편지의 위치(주소)**를 알려주는 것과 같음

---

## ✅ 클래스 상속

- `extends` 키워드를 사용하여 다른 클래스를 **상속**할 수 있음
- 부모 클래스(상위)는 **슈퍼 클래스**, 자식 클래스(하위)는 **서브 클래스**
- 자식 클래스는 부모 클래스의 멤버를 **그대로 물려받아 사용** 가능

> 👪 비유 : 자식이 부모의 유전자를 물려받는 것처럼,  
> 클래스를 재사용해서 **코드 중복을 줄이고 유지보수 용이**

---

## ✅ 상속의 필요성

- 중복되는 멤버를 상위 클래스(Person)로 올리고,  
  하위 클래스(Student, Professor 등)는 **특화된 기능만 추가**한다

> 🔁 비유 :  
> 모든 사람이 말하기/걷기/먹기를 하므로 ‘Person’에 정의하고,  
> 연구하기는 연구자만, 공부하기는 학생만 하도록 **구분된 기능을 추가**

---

## ✅ final 클래스와 메서드

- `final` 클래스: 더 이상 **상속할 수 없음**
- `final` 메서드: 더 이상 **오버라이딩 할 수 없음**

> 🚫 비유 :  
> - `final class`는 “이건 손대지 마!” 라는 **완성품**  
> - `final method`는 “이 부분은 수정 금지!”라는 **고정 기능**

---

## ✅ static 메서드의 제약 조건 1

- `static` 메서드는 **static 멤버만 접근 가능**
- 객체가 없어도 호출될 수 있으므로, 객체(인스턴스)의 멤버에는 접근할 수 없음

> 📡 비유 : 방송국(static)이 전국에 신호를 뿌리는 느낌.  
> 방송국은 전국에 알릴 수 있지만, **각 집 내부의 사적인 일(n)**은 알 수 없음

---

## ✅ static 메서드의 제약 조건 2

- `static` 메서드는 **this 사용 불가**
- this는 **객체 자기 자신을 가리키는 참조**인데,  
  static 메서드는 객체 없이도 호출되므로 존재하지 않음

> 📍 비유 : 사람이 존재해야 “나(this)”라는 말을 쓸 수 있는데,  
> 정적인 공간에서는 “나”라는 개념 자체가 없어서 this도 사용 불가!

# 📘 자바 상속, 객체 배열, 접근 제어자 정리

---

## 🧩 객체 배열

자바에서 객체 배열을 만들기 위해선 총 3단계가 필요해.

1. **배열 레퍼런스 변수 선언**  
   → `Circle[] c;`처럼 객체 타입 배열을 선언

2. **레퍼런스 배열 생성**  
   → `c = new Circle[5];` 배열 공간을 확보해

3. **배열의 각 요소(객체) 생성**  
   → `c[i] = new Circle(i);`처럼 실제 객체를 각 배열 칸에 채워 넣음

📦 비유:  
객체 배열은 **찬장이 비어있는 그릇들**이라고 생각하면 돼.  
처음엔 찬장을 만들고 (`new Circle[5]`), 그릇을 하나씩 채워넣어야 (`new Circle(i)`) 사용할 수 있어.

---

## 👨‍👩‍👧‍👦 상속의 필요성

클래스를 여러 개 만들다 보면 **중복 코드가 엄청 많아져서 유지보수 힘들어짐**.  
예: `말하기`, `먹기`, `걷기`, `자기` 같은 공통 기능이 각 클래스에 반복됨.

🌱 **상속을 사용하면**  
공통 기능을 하나의 클래스(`Person`)로 묶고  
다른 클래스들이 그걸 상속받아 중복을 줄일 수 있음.

> 📦 비유: 같은 회사에서 일하는 사람들이 기본 교육은 똑같이 받고, 각자 부서 업무만 추가로 배우는 것과 같음!

---

## 🚫 final 클래스와 final 메서드

- **final 클래스**  
  → 더 이상 상속 불가.  
  → 마치 완제품처럼 더 이상 확장하거나 바꿀 수 없음!

- **final 메서드**  
  → 오버라이딩(재정의) 불가능.  
  → 메서드 동작을 그대로 유지하고 싶을 때 사용.

> 🔒 비유:  
> `final` 클래스는 **출고된 봉인된 제품**  
> `final` 메서드는 **수정 불가능한 설명서**

---

## 👨‍👧 서브 클래스에서 슈퍼 클래스 접근

### 슈퍼 클래스의 필드/메서드 접근 가능 여부

| 접근 지정자 | 같은 패키지 | 다른 패키지 | 상속한 서브 클래스 |
|-------------|--------------|--------------|----------------------|
| `private`   | ❌           | ❌           | ❌                   |
| (default)   | ⭕           | ❌           | (패키지 동일 시) ⭕

| `protected` | ⭕           | ⭕ (상속 시) | ⭕                   |
| `public`    | ⭕           | ⭕           | ⭕                   |

- **private**: 오직 해당 클래스 안에서만 사용 가능
- **default**: 같은 패키지 안에서는 접근 가능
- **protected**: 같은 패키지 or 상속 관계에서는 접근 가능
- **public**: 어디서든 접근 가능

> 🔑 비유:  
> - `private`은 개인 일기장  
> - `protected`는 가족끼리 보는 단톡방  
> - `public`은 인스타 공개 계정!

---

## 🔐 protected 멤버 접근 요약

- 같은 패키지: 접근 허용
- 상속 관계: 패키지 상관없이 접근 허용
- 단, **객체를 통해 접근 불가**, 반드시 **상속한 서브 클래스 내부에서 직접 접근**해야 함

> 📦 비유: 부모님 집 열쇠는 상속받은 자식만 쓸 수 있음! (남이 못 씀)

---

## 📚 클래스 상속과 extends 키워드

- `extends`: 상속을 선언할 때 사용
- 부모 클래스: **슈퍼 클래스(super class)**
- 자식 클래스: **서브 클래스(sub class)**

> 예:  
> `class ColorPoint extends Point { ... }`  
> → `ColorPoint`는 `Point`를 확장(상속)한 클래스

---

## 📤 static 메서드의 제약 조건

1. **static 메서드는 오직 static 멤버만 접근 가능**
   - 객체 없이도 실행되므로, 인스턴스 필드 접근 ❌
   - `this` 키워드 사용 ❌

2. **static 메서드는 static 필드/메서드만 접근 가능**
   - static method 안에서는 다른 static method/변수는 사용 가능함

> 📦 비유:  
> `static`은 클래스 자체에서 작동하는 메서드니까,  
> **객체 없이 돌아가는 공장 설비**라고 생각하면 돼.  
> `this`는 객체 자신을 가리키는 건데, 공장 설비는 개인이 아니라서 `this`는 못 씀!

---

이렇게 정리해봤어!  
필요한 내용 더 추가하거나 형식 바꾸고 싶으면 얼마든지 말해줘 😎

## 클래스 상속과 객체에 대한 개념 정리

### 클래스와 객체의 상속 관계
- 클래스 간의 **상속(inheritance)**은 코드의 중복을 제거하고 재사용성을 높이기 위한 핵심 개념이다.
- `extends` 키워드를 사용해 **자식 클래스(서브 클래스)**가 **부모 클래스(슈퍼 클래스)**를 상속받을 수 있다.
- 슈퍼 클래스에 선언된 멤버 필드와 메서드는 서브 클래스에서 그대로 사용할 수 있다.
- 서브 클래스는 슈퍼 클래스의 기능을 물려받으면서, 추가적인 멤버나 기능을 확장할 수 있다.

### 서브 클래스 객체의 모양
- 서브 클래스의 객체는 슈퍼 클래스의 멤버도 포함하고 있다. 즉, 서브 클래스의 객체는 **슈퍼 클래스 + 서브 클래스**의 멤버로 구성된다.
- 객체 생성 시 서브 클래스의 생성자가 호출되지만, 그 전에 슈퍼 클래스의 생성자가 먼저 실행된다. 이걸 "**상속된 멤버 초기화**"라고 한다.

### 생성자의 선택과 실행 순서
- 슈퍼 클래스와 서브 클래스는 각각 여러 개의 생성자를 가질 수 있다.
- **서브 클래스 객체가 생성되면**, 슈퍼 클래스의 생성자 1개 + 서브 클래스 생성자 1개가 **모두 실행**된다.
- 생성자 호출 순서: **서브 클래스의 생성자 호출 → 내부에서 슈퍼 클래스 생성자 호출**
- 실행 순서: **슈퍼 클래스 생성자 먼저 실행 → 서브 클래스 생성자 실행**

### 생성자 선택 방식
1. **개발자의 명시적 선택**: 서브 클래스에서 `super()` 키워드를 사용해 슈퍼 클래스의 생성자를 직접 호출.
2. **컴파일러에 의한 기본 생성자 자동 선택**:
   - 서브 클래스 생성자에서 `super()`를 명시하지 않으면, **컴파일러가 자동으로 슈퍼 클래스의 기본 생성자를 호출**함.
   - 슈퍼 클래스에 기본 생성자가 없으면 **오류 발생**.

### 생성자 호출 관련 예외 상황
- **슈퍼 클래스에 기본 생성자가 없는데**, 서브 클래스가 `super()`를 명시적으로 호출하지 않으면 오류가 발생한다.
- 오류 메시지 예시: `Implicit super constructor A() is undefined. Must explicitly invoke another constructor`.

### 접근 지정자에 따른 상속 접근 제한
- `private`: 서브 클래스에서 접근 불가
- **default(디폴트)**: 같은 패키지 안에 있을 경우 접근 가능
- `protected`: 같은 패키지거나 상속받은 서브 클래스이면 접근 가능
- `public`: 어디서든 접근 가능

#### 접근 가능 여부 요약표

| 클래스 종류             | private | default | protected | public |
|------------------------|---------|---------|-----------|--------|
| 같은 패키지의 클래스       | ❌      | ⭕      | ⭕        | ⭕     |
| 다른 패키지의 클래스       | ❌      | ❌      | ❌        | ⭕     |
| 같은 패키지의 서브 클래스 | ❌      | ⭕      | ⭕        | ⭕     |
| 다른 패키지의 서브 클래스 | ❌      | ❌      | ⭕        | ⭕     |

- `protected` 멤버는 같은 패키지의 클래스들에게 모두 허용되며, **다른 패키지라도 서브 클래스라면 접근 가능**하다.
- `private` 멤버는 오직 해당 클래스 내부에서만 접근 가능하다.

### 비유를 들어 정리하면?
- **슈퍼 클래스**는 부모님, **서브 클래스**는 자식.
- 부모님이 집(객체)을 지어놓고 자식은 그 집을 물려받아 꾸미는 느낌.
- 부모님이 열쇠(멤버 변수와 메서드)를 주면 자식은 그것을 쓰고 확장할 수 있음.
- 하지만 열쇠 중 일부(`private`)는 부모님만 쓸 수 있고 자식은 못 씀.
- 생성자는 집을 지을 때 사용하는 설계도 같은 역할. 부모 집 먼저 지어야 자식 집도 완성 가능.


# 📘 자바의 업캐스팅, 다운캐스팅, 오버라이딩 개념 정리

## ✅ 개념 요약

자바에서 오버라이딩(Overriding)은 부모 클래스의 메서드를 자식 클래스에서 동일한 이름과 매개변수 구조로 다시 정의하는 기능이다. 이를 통해 하나의 메서드 이름이 실제 객체에 따라 다르게 동작하는 다형성(Polymorphism)을 구현할 수 있다. 실행 시점에 어떤 메서드가 실행될지는 실제 객체의 타입에 따라 결정되며, 이를 동적 바인딩(Dynamic Binding)이라고 한다. 예를 들어 `Shape` 클래스의 `draw()` 메서드를 `Circle`, `Rect`, `Line`에서 각각 오버라이딩하면, `Shape` 타입의 변수로 호출하더라도 실제 객체 타입에 따라 다른 결과가 실행된다. 이건 마치 같은 대사를 주더라도 배우마다 연기 방식이 달라지는 것처럼 객체에 따라 메서드 동작이 달라지는 것이다.

업캐스팅(Upcasting)은 자식 객체를 부모 클래스 타입으로 참조하는 것으로, `Student` 객체를 `Person` 타입으로 선언하면 부모 클래스에 정의된 멤버들만 접근할 수 있고 자식 클래스의 고유 멤버들은 사용할 수 없게 된다. 이건 고양이, 사람, 돌고래를 모두 '생물'이라는 상위 개념 박스에 담아 공통된 특성만 사용하는 것과 같다. 업캐스팅은 자동 형변환이며, 다형성을 위해 자주 활용된다. 특히 다양한 자식 객체를 하나의 배열이나 리스트에 담기 위해 자주 사용되는데, 예를 들어 `Person[] arr = new Person[3];`처럼 선언하면 `Student`, `Professor`, `Researcher` 객체를 함께 담을 수 있다. 이건 다양한 과일을 하나의 “과일 박스”에 담는 느낌이다.

다운캐스팅(Downcasting)은 업캐스팅된 부모 타입 객체를 다시 자식 타입으로 변환하여 자식 클래스 고유 기능을 사용할 수 있게 한다. 이건 ‘생물’ 박스에서 고양이를 꺼내 고양이로서의 특성을 쓰는 것과 같은 개념이다. 하지만 이때는 명시적인 형변환이 필요하고, 실제 객체가 자식 클래스가 아니면 오류가 발생하므로 주의가 필요하다. 따라서 안전한 형변환을 위해 instanceof 연산자를 사용한다.

`instanceof`는 객체가 특정 클래스의 인스턴스인지 확인하는 연산자이며, 박스에 뭐가 들어있는지 라벨을 확인하는 것처럼 미리 검사할 수 있다. 예를 들어 `if (p instanceof Student)`처럼 확인한 뒤 `(Student)p`로 형변환을 하면 안전하게 자식 멤버를 사용할 수 있다.

이처럼 업캐스팅은 유연한 설계를 가능하게 하고, 다운캐스팅은 필요할 때 세부 기능을 활용할 수 있도록 해준다. 모든 객체를 하나의 부모 타입 배열에 담아 다형성을 실현하고, 필요할 때 다시 자식 형태로 꺼내어 활용하는 방식은 자바의 객체지향 설계에서 매우 핵심적인 구조다.

---

## 🧠 개념 요약 표

| 항목             | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| 오버라이딩        | 부모 메서드를 자식이 재정의 → 다형성 구현                             |
| 업캐스팅          | 자식 → 부모로 형변환 (자동) → 부모 멤버만 접근 가능                   |
| 다운캐스팅        | 부모 → 자식으로 형변환 (명시적 필요) → 자식 멤버 접근 가능            |
| instanceof       | 형변환 전에 객체 타입 체크 (안전한 다운캐스팅에 필수)                  |
| 다형성            | 같은 메서드 호출이 객체에 따라 다르게 반응함 (동적 바인딩 기반)        |

---

## 🔍 코드 예시

```java
// 업캐스팅
Student s = new Student("홍길동");
Person p = s;  // 업캐스팅 (자동)

// 접근 가능
System.out.println(p.name);    // ✅ 부모 멤버
// System.out.println(p.grade); // ❌ 자식 멤버 접근 불가

// 다운캐스팅
if (p instanceof Student) {
    Student s2 = (Student)p;
    System.out.println(s2.grade);  // ✅ 자식 멤버 사용 가능
}

