# 📘 2025년 4월 17일 자바 수업 정리

---

## ✅ 생성자의 종류

- 생성자는 객체를 만들 때 자동으로 호출되어 **객체를 초기화**하는 메서드다.
- **클래스 이름과 동일한 이름을 가지며, 반환 타입이 없다 (void도 사용 ❌)**

### 🛠 기본 생성자 (Default Constructor)

- 매개변수가 없고, 아무 작업도 하지 않는 단순한 생성자
- 클래스에 생성자가 아무것도 선언되어 있지 않으면 **컴파일러가 자동으로 생성**해준다

> 🔧 비유 : 공장에서 물건을 만들 때, 옵션 없이 **기본 구성으로 출고**되는 느낌

### ❗ 기본 생성자가 자동 생성되지 않는 경우

- 사용자가 직접 다른 생성자를 작성한 경우, 기본 생성자는 **자동으로 생성되지 않음**
- 이 경우 기본 생성자를 **명시적으로 정의해야 함**

> ⚠️ 비유 : 고객이 “특수 옵션”을 요구해서 공장에서 기본 옵션을 **자동으로 생략한 상황**

---

## ✅ 객체 속에서의 this

- `this`는 **자기 자신 객체를 가리키는 참조 변수**
- 필드 이름과 매개변수 이름이 겹칠 때 사용하여 **구분**해준다

> 🙋 비유 : "나 자신을 가리키는 말" — 같은 반에 ‘영수’가 둘일 때, “이 영수요!” 하고 **자기 자신을 가리키는 느낌**

---

## ✅ this 레퍼런스

- 객체 자기 자신에 대한 참조값을 가지고 있음
- **컴파일러가 자동으로 처리**, 개발자가 직접 선언하지 않아도 된다
- `this.변수` 형태로 **객체 내 필드에 접근**할 때 주로 사용됨

> 📦 비유 : 택배 상자 안에 “이 상자 안에 든 물건”이라고 라벨링 해두는 느낌

---

## ✅ 생성자에서의 this()

- 하나의 생성자에서 **다른 생성자를 호출**할 때 사용 (`this(...)`)
- 반드시 **생성자 내부 첫 줄에 위치해야 함**
- 생성자 코드 중복을 줄일 수 있음

> 🔁 비유 : 레시피 A를 만들기 위해 레시피 B를 **먼저 실행한 후**에 A를 계속하는 느낌  
> (예: “먼저 반죽 만들기(this), 그 후에 굽기”)

---

## ❌ this() 사용 실패 예

- `this()`는 생성자 내부에서만 사용 가능
- 일반 메서드에서는 사용할 수 없음
- 생성자 호출은 **무조건 첫 줄에 와야 함**, 다른 문장이 먼저 오면 컴파일 에러

---

## ✅ 멤버의 접근 지정자

- 접근 지정자는 **클래스의 멤버(변수/메서드)의 접근 범위를 지정**한다

| 지정자      | 접근 가능 범위 |
|-------------|----------------|
| `public`    | 모든 클래스에서 접근 가능 |
| (default)   | 같은 패키지 내 클래스만 접근 가능 |
| `private`   | 같은 클래스 내에서만 접근 가능 |

> 🔒 비유 :  
> - `public` = 누구나 출입 가능한 공공장소  
> - `default` = 회사 출입증 있는 사람만 들어갈 수 있는 구역  
> - `private` = 집 안방처럼 본인만 들어갈 수 있음

---

## ✅ 배열을 인자로 전달할 때 (배열 참조 전달)

- 자바에서는 배열을 메서드에 전달할 때 **배열의 참조(주소)**가 전달됨
- 메서드 안에서 배열 내용을 바꾸면 **원래 배열에도 영향을 줌**

> 📬 비유 : 편지를 복사해서 주는 게 아니라, **원본 편지의 위치(주소)**를 알려주는 것과 같음

---

## ✅ 클래스 상속

- `extends` 키워드를 사용하여 다른 클래스를 **상속**할 수 있음
- 부모 클래스(상위)는 **슈퍼 클래스**, 자식 클래스(하위)는 **서브 클래스**
- 자식 클래스는 부모 클래스의 멤버를 **그대로 물려받아 사용** 가능

> 👪 비유 : 자식이 부모의 유전자를 물려받는 것처럼,  
> 클래스를 재사용해서 **코드 중복을 줄이고 유지보수 용이**

---

## ✅ 상속의 필요성

- 중복되는 멤버를 상위 클래스(Person)로 올리고,  
  하위 클래스(Student, Professor 등)는 **특화된 기능만 추가**한다

> 🔁 비유 :  
> 모든 사람이 말하기/걷기/먹기를 하므로 ‘Person’에 정의하고,  
> 연구하기는 연구자만, 공부하기는 학생만 하도록 **구분된 기능을 추가**

---

## ✅ final 클래스와 메서드

- `final` 클래스: 더 이상 **상속할 수 없음**
- `final` 메서드: 더 이상 **오버라이딩 할 수 없음**

> 🚫 비유 :  
> - `final class`는 “이건 손대지 마!” 라는 **완성품**  
> - `final method`는 “이 부분은 수정 금지!”라는 **고정 기능**

---

## ✅ static 메서드의 제약 조건 1

- `static` 메서드는 **static 멤버만 접근 가능**
- 객체가 없어도 호출될 수 있으므로, 객체(인스턴스)의 멤버에는 접근할 수 없음

> 📡 비유 : 방송국(static)이 전국에 신호를 뿌리는 느낌.  
> 방송국은 전국에 알릴 수 있지만, **각 집 내부의 사적인 일(n)**은 알 수 없음

---

## ✅ static 메서드의 제약 조건 2

- `static` 메서드는 **this 사용 불가**
- this는 **객체 자기 자신을 가리키는 참조**인데,  
  static 메서드는 객체 없이도 호출되므로 존재하지 않음

> 📍 비유 : 사람이 존재해야 “나(this)”라는 말을 쓸 수 있는데,  
> 정적인 공간에서는 “나”라는 개념 자체가 없어서 this도 사용 불가!

# 📘 자바 상속, 객체 배열, 접근 제어자 정리

---

## 🧩 객체 배열

자바에서 객체 배열을 만들기 위해선 총 3단계가 필요해.

1. **배열 레퍼런스 변수 선언**  
   → `Circle[] c;`처럼 객체 타입 배열을 선언

2. **레퍼런스 배열 생성**  
   → `c = new Circle[5];` 배열 공간을 확보해

3. **배열의 각 요소(객체) 생성**  
   → `c[i] = new Circle(i);`처럼 실제 객체를 각 배열 칸에 채워 넣음

📦 비유:  
객체 배열은 **찬장이 비어있는 그릇들**이라고 생각하면 돼.  
처음엔 찬장을 만들고 (`new Circle[5]`), 그릇을 하나씩 채워넣어야 (`new Circle(i)`) 사용할 수 있어.

---

## 👨‍👩‍👧‍👦 상속의 필요성

클래스를 여러 개 만들다 보면 **중복 코드가 엄청 많아져서 유지보수 힘들어짐**.  
예: `말하기`, `먹기`, `걷기`, `자기` 같은 공통 기능이 각 클래스에 반복됨.

🌱 **상속을 사용하면**  
공통 기능을 하나의 클래스(`Person`)로 묶고  
다른 클래스들이 그걸 상속받아 중복을 줄일 수 있음.

> 📦 비유: 같은 회사에서 일하는 사람들이 기본 교육은 똑같이 받고, 각자 부서 업무만 추가로 배우는 것과 같음!

---

## 🚫 final 클래스와 final 메서드

- **final 클래스**  
  → 더 이상 상속 불가.  
  → 마치 완제품처럼 더 이상 확장하거나 바꿀 수 없음!

- **final 메서드**  
  → 오버라이딩(재정의) 불가능.  
  → 메서드 동작을 그대로 유지하고 싶을 때 사용.

> 🔒 비유:  
> `final` 클래스는 **출고된 봉인된 제품**  
> `final` 메서드는 **수정 불가능한 설명서**

---

## 👨‍👧 서브 클래스에서 슈퍼 클래스 접근

### 슈퍼 클래스의 필드/메서드 접근 가능 여부

| 접근 지정자 | 같은 패키지 | 다른 패키지 | 상속한 서브 클래스 |
|-------------|--------------|--------------|----------------------|
| `private`   | ❌           | ❌           | ❌                   |
| (default)   | ⭕           | ❌           | (패키지 동일 시) ⭕

| `protected` | ⭕           | ⭕ (상속 시) | ⭕                   |
| `public`    | ⭕           | ⭕           | ⭕                   |

- **private**: 오직 해당 클래스 안에서만 사용 가능
- **default**: 같은 패키지 안에서는 접근 가능
- **protected**: 같은 패키지 or 상속 관계에서는 접근 가능
- **public**: 어디서든 접근 가능

> 🔑 비유:  
> - `private`은 개인 일기장  
> - `protected`는 가족끼리 보는 단톡방  
> - `public`은 인스타 공개 계정!

---

## 🔐 protected 멤버 접근 요약

- 같은 패키지: 접근 허용
- 상속 관계: 패키지 상관없이 접근 허용
- 단, **객체를 통해 접근 불가**, 반드시 **상속한 서브 클래스 내부에서 직접 접근**해야 함

> 📦 비유: 부모님 집 열쇠는 상속받은 자식만 쓸 수 있음! (남이 못 씀)

---

## 📚 클래스 상속과 extends 키워드

- `extends`: 상속을 선언할 때 사용
- 부모 클래스: **슈퍼 클래스(super class)**
- 자식 클래스: **서브 클래스(sub class)**

> 예:  
> `class ColorPoint extends Point { ... }`  
> → `ColorPoint`는 `Point`를 확장(상속)한 클래스

---

## 📤 static 메서드의 제약 조건

1. **static 메서드는 오직 static 멤버만 접근 가능**
   - 객체 없이도 실행되므로, 인스턴스 필드 접근 ❌
   - `this` 키워드 사용 ❌

2. **static 메서드는 static 필드/메서드만 접근 가능**
   - static method 안에서는 다른 static method/변수는 사용 가능함

> 📦 비유:  
> `static`은 클래스 자체에서 작동하는 메서드니까,  
> **객체 없이 돌아가는 공장 설비**라고 생각하면 돼.  
> `this`는 객체 자신을 가리키는 건데, 공장 설비는 개인이 아니라서 `this`는 못 씀!

---

이렇게 정리해봤어!  
필요한 내용 더 추가하거나 형식 바꾸고 싶으면 얼마든지 말해줘 😎