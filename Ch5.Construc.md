# 📘 4월 17일 자바 수업 정리

---

## 1️⃣ 생성자 – 기본 생성자 (Default Constructor)

- 매개변수가 없고, 내부에서 아무 작업도 하지 않는 생성자
- 생성자를 작성하지 않으면 자바가 자동으로 `클래스명()` 생성자 만들어줌

> 🧠 비유: 옵션 안 고르고 그냥 기본으로 계약한 원룸 느낌

---

## 2️⃣ 생성자가 자동 생성되지 않는 경우

- 생성자를 하나라도 직접 작성하면, 자바는 기본 생성자를 더 이상 자동으로 만들지 않음
- 기본 생성자를 사용하고 싶다면, 반드시 명시적으로 `public 클래스명() {}` 작성해야 함

> 🧠 비유: 내가 원하는 옵션 방을 직접 골랐기 때문에, 자동 기본 옵션 제공은 중단됨

---

## 3️⃣ this 레퍼런스

- `this`는 객체 자기 자신을 참조하는 키워드
- 주로 멤버 변수와 매개변수 이름이 겹칠 때 구분용으로 사용

> 🧠 비유: “내 거야”라고 말할 때의 ‘나’와 같은 느낌

---

## 4️⃣ 객체 안에서의 this

- `this`는 메서드를 호출한 객체를 가리킴
- ob1, ob2, ob3가 각각 `set()`을 호출하면, `this`는 각각 ob1, ob2, ob3를 참조

> 🧠 비유: 학생 세 명이 “내 노트”라고 말하면, 각자 자기 노트를 말하는 것과 같음

---

## 5️⃣ this()로 다른 생성자 호출

- 같은 클래스의 다른 생성자를 호출할 때 사용
- 생성자 안에서만 사용 가능하며, 반드시 **첫 줄**에 위치해야 함

> 🧠 비유: 같은 가게에서 세트 메뉴 하나 먼저 부르고, 거기에 추가로 토핑을 올리는 느낌

---

## 6️⃣ 인자 전달 – 배열이 전달되는 경우

- 배열은 **값이 아닌 참조(레퍼런스)**가 전달됨
- 메서드에서 배열을 변경하면, 원본 배열도 바뀜

> 🧠 비유: 종이 한 장을 복사하는 게 아니라, 같은 종이를 같이 쓰는 것

---

## 7️⃣ 인자 전달 – 객체가 전달되는 경우

- 객체도 배열과 마찬가지로 참조가 전달됨
- 전달된 객체 내부 상태가 변경되면, 호출한 쪽 객체도 함께 바뀜

---

## 8️⃣ 인자 전달 – 기본 타입의 값이 전달되는 경우

- `int`, `double` 등 기본형 타입은 **값 자체**가 복사되어 전달됨
- 메서드 내부에서 변경해도, 원본 값은 바뀌지 않음

> 🧠 비유: 사본을 받은 후 내가 거기 낙서해도, 원본 종이는 그대로인 느낌

---

## 9️⃣ 예제 – 인자로 배열이 전달되는 예

- `char[]` 배열을 전달받아, 공백(' ')을 `','`로 바꾸는 메서드 작성
- 배열을 메서드에 전달하면, 원본 배열도 같이 변경됨

---

## 🔁 메서드 오버로딩 (Overloading)

- 같은 이름의 메서드를 **매개변수의 타입이나 개수**만 다르게 해서 여러 개 정의
- 리턴 타입은 오버로딩과 관계 없음

> 🧠 비유: 같은 가게에서 “주문”이라고 말했지만, 사람마다 메뉴가 다른 경우

---

## 🧱 객체 배열 선언과 생성 과정

### 자바의 객체 배열 만들기 3단계

1. 객체 배열 변수 선언  
   → `Circle[] c;`
2. 배열 공간 확보  
   → `c = new Circle[5];`
3. 배열 각 칸에 실제 객체 생성  
   → `c[i] = new Circle(i);`

---

## 🔧 메서드

- 자바의 함수 = 메서드
- 모든 메서드는 반드시 클래스 내부에 선언되어야 함 (캡슐화 원칙)
- 메서드는 다음과 같은 구성 요소를 가짐:

  - 접근 지정자 (예: `public`)
  - 리턴 타입 (예: `int`)
  - 메서드 이름 (예: `getSum`)
  - 매개변수 목록 (예: `int i, int j`)
  - 본문 코드

---

## 예제 – Circle 배열 만들기

- `Circle` 객체를 5개 생성하고, 각각 반지름 0~4를 넣어 저장
- 이후 배열을 순회하며 각 객체의 면적을 출력함

# 📘 자바 접근 지정자, static 멤버, 가비지 컬렉션 정리

## 1️⃣ 멤버 접근 지정자

| 접근 지정자 | 같은 패키지 | 다른 패키지 | 상속 관계 | 설명 |
|-------------|--------------|--------------|------------|------|
| `private`   | ❌           | ❌           | ❌         | 같은 클래스 내부에서만 접근 가능 |
| `default`   | ⭕           | ❌           | ❌         | 같은 패키지 내의 클래스만 접근 가능 |
| `protected` | ⭕           | ❌           | ⭕         | 같은 패키지 + 다른 패키지 자식 클래스도 접근 가능 |
| `public`    | ⭕           | ⭕           | ⭕         | 모든 클래스에서 접근 가능 |

> 📌 비유:  
> `private`는 **집 비밀번호**,  
> `default`는 **우리 아파트 주민 전용**,  
> `protected`는 **친척들까지 들어올 수 있음**,  
> `public`은 **누구든 환영하는 오픈 행사** 느낌이야!

---

## 2️⃣ 클래스 접근 지정자

- `public` 클래스: 모든 패키지에서 접근 가능  
- `default` 클래스: 같은 패키지에서만 접근 가능  

> 🏠 비유:  
> `public class`는 누구나 들어올 수 있는 **오픈 카페**,  
> `default class`는 아파트 **입주민 전용 커뮤니티 센터**!

---

## 3️⃣ 접근 지정자의 목적

- **객체지향의 캡슐화** 원칙을 지키기 위해 멤버 접근을 제어함
- 정보를 숨기고 필요한 것만 외부에 공개하도록 함

> 🔐 비유:  
> 클래스는 **비밀 금고**,  
> 접근 지정자는 **열쇠 권한**을 관리하는 느낌!

---

## 4️⃣ 자바의 패키지 개념

- 관련된 클래스들을 묶는 **폴더(디렉토리)**
- 하나의 자바 응용프로그램은 여러 개의 패키지로 구성됨

> 📦 비유:  
> 패키지는 **문서철 폴더**,  
> 클래스는 그 안에 있는 **문서 한 장**이야!

---

## 5️⃣ 가비지 컬렉션 개념

- JVM이 **사용하지 않는 객체(가비지)**를 자동으로 회수함
- `System.gc()` 또는 `Runtime.getRuntime().gc()`로 수동 요청 가능

> 🧹 비유:  
> 안 쓰는 변수는 **쓰레기**,  
> 가비지 컬렉터는 **청소부**!

---

## 6️⃣ 가비지 발생 예시

```java
String a = new String("Good");
a = null; // "Good"은 가비지 발생



Person a = new Person("홍길동");
Person b = new Person("이몽룡");
b = a; // 이전 b가 가리키던 객체는 가비지

🪙 비유:
b가 새 장난감을 사면서 예전 장난감은 버림받은 상태!
```
# 📘 자바 접근 지정자, static 멤버, 가비지 컬렉션 정리

## 1️⃣ 멤버 접근 지정자

| 접근 지정자 | 같은 패키지 | 다른 패키지 | 상속 관계 | 설명 |
|-------------|--------------|--------------|------------|------|
| `private`   | ❌           | ❌           | ❌         | 같은 클래스 내부에서만 접근 가능 |
| `default`   | ⭕           | ❌           | ❌         | 같은 패키지 내의 클래스만 접근 가능 |
| `protected` | ⭕           | ❌           | ⭕         | 같은 패키지 + 다른 패키지 자식 클래스도 접근 가능 |
| `public`    | ⭕           | ⭕           | ⭕         | 모든 클래스에서 접근 가능 |

> 📌 비유:  
> `private`는 **집 비밀번호**,  
> `default`는 **우리 아파트 주민 전용**,  
> `protected`는 **친척들까지 들어올 수 있음**,  
> `public`은 **누구든 환영하는 오픈 행사** 느낌이야!

---

## 2️⃣ 클래스 접근 지정자

- `public` 클래스: 모든 패키지에서 접근 가능  
- `default` 클래스: 같은 패키지에서만 접근 가능  

> 🏠 비유:  
> `public class`는 누구나 들어올 수 있는 **오픈 카페**,  
> `default class`는 아파트 **입주민 전용 커뮤니티 센터**!

---

## 3️⃣ 접근 지정자의 목적

- **객체지향의 캡슐화** 원칙을 지키기 위해 멤버 접근을 제어함
- 정보를 숨기고 필요한 것만 외부에 공개하도록 함

> 🔐 비유:  
> 클래스는 **비밀 금고**,  
> 접근 지정자는 **열쇠 권한**을 관리하는 느낌!

---

## 4️⃣ 자바의 패키지 개념

- 관련된 클래스들을 묶는 **폴더(디렉토리)**
- 하나의 자바 응용프로그램은 여러 개의 패키지로 구성됨

> 📦 비유:  
> 패키지는 **문서철 폴더**,  
> 클래스는 그 안에 있는 **문서 한 장**이야!

---

## 5️⃣ 가비지 컬렉션 개념

- JVM이 **사용하지 않는 객체(가비지)**를 자동으로 회수함
- `System.gc()` 또는 `Runtime.getRuntime().gc()`로 수동 요청 가능

> 🧹 비유:  
> 안 쓰는 변수는 **쓰레기**,  
> 가비지 컬렉터는 **청소부**!

---

## 6️⃣ 가비지 발생 예시

```java
String a = new String("Good");
a = null; // "Good"은 가비지 발생
```

> 📉 참조가 사라지는 순간, 힙 메모리 안의 객체는 가비지!

---

## 7️⃣ 가비지 예제 (레퍼런스 교체)

```java
Person a = new Person("홍길동");
Person b = new Person("이몽룡");
b = a; // 이전 b가 가리키던 객체는 가비지
```

> 🪙 비유:  
> b가 새 장난감을 사면서 예전 장난감은 **버림받은 상태**!

---

## 8️⃣ 객체 소멸 개념

- `new`로 만든 객체는 **JVM의 힙**에 저장됨
- 더 이상 사용하지 않으면 GC가 회수

> 🚮 자바는 쓰레기 버리는 걸 **직접 안 해도 되는 편리함**이 있어

---

## 9️⃣ 객체 치환 시 주의

```java
ob1 = ob2; // ob1이 가리키던 객체는 더 이상 접근 불가 → 가비지
```

> 🎯 복사는 내용이 아니라 **참조(화살표)**가 바뀌는 거야!

---

## 🔟 오버로딩 실패 예시

```java
public int getSum(int i, int j) { ... }
public double getSum(int i, int j) { ... } // ❌ 실패
```

> ⚠️ 매개변수의 개수나 타입이 달라야 오버로딩 성공!

---

## 1️⃣1️⃣ static 메서드 예제

```java
public class Calc {
    public static int abs(int a) { return a > 0 ? a : -a; }
    public static int max(int a, int b) { return a > b ? a : b; }
    public static int min(int a, int b) { return a > b ? b : a; }
}
```

> 🧮 전역 유틸 클래스의 대표적인 예: `Math.abs()`, `Math.max()` 처럼 사용!

---

## 1️⃣2️⃣ static 메서드 제약 조건

- static 메서드는 **static 멤버만 접근 가능**
- 객체 생성 없이 실행되므로 non-static 멤버는 사용 불가

> 🧱 비유:  
> 건물 설계도만 있는 상태에선 **내부 가구 배치(객체 멤버)**는 접근 불가!

---

## 1️⃣3️⃣ static의 활용

- **전역 변수 / 전역 함수** 느낌
- **공통 속성 또는 기능** 정의 시 사용

---

## 1️⃣4️⃣ static 멤버 생성

- 클래스당 **하나만 생성됨**
- 모든 객체가 공유

> 👥 비유:  
> 학교 전체가 공유하는 **학칙**,  
> 반마다 있는 건 아님!

---

## 1️⃣5️⃣ static 멤버 사용 방법

- 클래스 이름으로 직접 접근
```java
StaticSample.m = 5;
StaticSample.f();
```
- 객체 이름으로도 접근 가능
```java
obj.m = 5;
obj.f();
```

---

## 1️⃣6️⃣ non-static 멤버 접근 불가 예시

```java
StaticSample.n = 5; // ❌ 오류
StaticSample.g();   // ❌ 오류
```

> ❗ 객체가 생성되어야 사용할 수 있음!

---

## 1️⃣7️⃣ static vs non-static 차이

| 특성 | non-static | static |
|------|------------|--------|
| 생성 시점 | 객체 생성 시 | 클래스 로딩 시 |
| 생성 수 | 객체마다 별도 | 클래스당 1개 |
| 메모리 위치 | 힙 영역 | 메서드 영역 |
| 공유 여부 | ❌ | ⭕ |

---

## 1️⃣8️⃣ static 멤버는 언제 생성?

- 객체 없이도 생성됨  
- 모든 객체가 같은 static 멤버를 공유

---

## 1️⃣9️⃣ static 멤버 선언 예시

```java
class StaticSample {
    static int m;
    static void f() { ... }
}
```

---

## 2️⃣0️⃣ 접근 지정자 예제

```java
class Sample {
    public int a;
    private int b;
    int c; // default
}

public class AccessEx {
    public static void main(String[] args) {
        Sample s = new Sample();
        s.a = 10; // ⭕
        s.b = 10; // ❌ private
        s.c = 10; // ⭕ default (같은 패키지)
    }
}
```

