# 📘 4월 17일 자바 수업 정리

---

## 1️⃣ 생성자 – 기본 생성자 (Default Constructor)

- 매개변수가 없고, 내부에서 아무 작업도 하지 않는 생성자
- 생성자를 작성하지 않으면 자바가 자동으로 `클래스명()` 생성자 만들어줌

> 🧠 비유: 옵션 안 고르고 그냥 기본으로 계약한 원룸 느낌

---

## 2️⃣ 생성자가 자동 생성되지 않는 경우

- 생성자를 하나라도 직접 작성하면, 자바는 기본 생성자를 더 이상 자동으로 만들지 않음
- 기본 생성자를 사용하고 싶다면, 반드시 명시적으로 `public 클래스명() {}` 작성해야 함

> 🧠 비유: 내가 원하는 옵션 방을 직접 골랐기 때문에, 자동 기본 옵션 제공은 중단됨

---

## 3️⃣ this 레퍼런스

- `this`는 객체 자기 자신을 참조하는 키워드
- 주로 멤버 변수와 매개변수 이름이 겹칠 때 구분용으로 사용

> 🧠 비유: “내 거야”라고 말할 때의 ‘나’와 같은 느낌

---

## 4️⃣ 객체 안에서의 this

- `this`는 메서드를 호출한 객체를 가리킴
- ob1, ob2, ob3가 각각 `set()`을 호출하면, `this`는 각각 ob1, ob2, ob3를 참조

> 🧠 비유: 학생 세 명이 “내 노트”라고 말하면, 각자 자기 노트를 말하는 것과 같음

---

## 5️⃣ this()로 다른 생성자 호출

- 같은 클래스의 다른 생성자를 호출할 때 사용
- 생성자 안에서만 사용 가능하며, 반드시 **첫 줄**에 위치해야 함

> 🧠 비유: 같은 가게에서 세트 메뉴 하나 먼저 부르고, 거기에 추가로 토핑을 올리는 느낌

---

## 6️⃣ 인자 전달 – 배열이 전달되는 경우

- 배열은 **값이 아닌 참조(레퍼런스)**가 전달됨
- 메서드에서 배열을 변경하면, 원본 배열도 바뀜

> 🧠 비유: 종이 한 장을 복사하는 게 아니라, 같은 종이를 같이 쓰는 것

---

## 7️⃣ 인자 전달 – 객체가 전달되는 경우

- 객체도 배열과 마찬가지로 참조가 전달됨
- 전달된 객체 내부 상태가 변경되면, 호출한 쪽 객체도 함께 바뀜

---

## 8️⃣ 인자 전달 – 기본 타입의 값이 전달되는 경우

- `int`, `double` 등 기본형 타입은 **값 자체**가 복사되어 전달됨
- 메서드 내부에서 변경해도, 원본 값은 바뀌지 않음

> 🧠 비유: 사본을 받은 후 내가 거기 낙서해도, 원본 종이는 그대로인 느낌

---

## 9️⃣ 예제 – 인자로 배열이 전달되는 예

- `char[]` 배열을 전달받아, 공백(' ')을 `','`로 바꾸는 메서드 작성
- 배열을 메서드에 전달하면, 원본 배열도 같이 변경됨

---

## 🔁 메서드 오버로딩 (Overloading)

- 같은 이름의 메서드를 **매개변수의 타입이나 개수**만 다르게 해서 여러 개 정의
- 리턴 타입은 오버로딩과 관계 없음

> 🧠 비유: 같은 가게에서 “주문”이라고 말했지만, 사람마다 메뉴가 다른 경우

---

## 🧱 객체 배열 선언과 생성 과정

### 자바의 객체 배열 만들기 3단계

1. 객체 배열 변수 선언  
   → `Circle[] c;`
2. 배열 공간 확보  
   → `c = new Circle[5];`
3. 배열 각 칸에 실제 객체 생성  
   → `c[i] = new Circle(i);`

---

## 🔧 메서드

- 자바의 함수 = 메서드
- 모든 메서드는 반드시 클래스 내부에 선언되어야 함 (캡슐화 원칙)
- 메서드는 다음과 같은 구성 요소를 가짐:

  - 접근 지정자 (예: `public`)
  - 리턴 타입 (예: `int`)
  - 메서드 이름 (예: `getSum`)
  - 매개변수 목록 (예: `int i, int j`)
  - 본문 코드

---

## 예제 – Circle 배열 만들기

- `Circle` 객체를 5개 생성하고, 각각 반지름 0~4를 넣어 저장
- 이후 배열을 순회하며 각 객체의 면적을 출력함

# 📘 자바 접근 지정자, static 멤버, 가비지 컬렉션 정리

## 1️⃣ 멤버 접근 지정자

| 접근 지정자 | 같은 패키지 | 다른 패키지 | 상속 관계 | 설명 |
|-------------|--------------|--------------|------------|------|
| `private`   | ❌           | ❌           | ❌         | 같은 클래스 내부에서만 접근 가능 |
| `default`   | ⭕           | ❌           | ❌         | 같은 패키지 내의 클래스만 접근 가능 |
| `protected` | ⭕           | ❌           | ⭕         | 같은 패키지 + 다른 패키지 자식 클래스도 접근 가능 |
| `public`    | ⭕           | ⭕           | ⭕         | 모든 클래스에서 접근 가능 |

> 📌 비유:  
> `private`는 **집 비밀번호**,  
> `default`는 **우리 아파트 주민 전용**,  
> `protected`는 **친척들까지 들어올 수 있음**,  
> `public`은 **누구든 환영하는 오픈 행사** 느낌이야!

---

## 2️⃣ 클래스 접근 지정자

- `public` 클래스: 모든 패키지에서 접근 가능  
- `default` 클래스: 같은 패키지에서만 접근 가능  

> 🏠 비유:  
> `public class`는 누구나 들어올 수 있는 **오픈 카페**,  
> `default class`는 아파트 **입주민 전용 커뮤니티 센터**!

---

## 3️⃣ 접근 지정자의 목적

- **객체지향의 캡슐화** 원칙을 지키기 위해 멤버 접근을 제어함
- 정보를 숨기고 필요한 것만 외부에 공개하도록 함

> 🔐 비유:  
> 클래스는 **비밀 금고**,  
> 접근 지정자는 **열쇠 권한**을 관리하는 느낌!

---

## 4️⃣ 자바의 패키지 개념

- 관련된 클래스들을 묶는 **폴더(디렉토리)**
- 하나의 자바 응용프로그램은 여러 개의 패키지로 구성됨

> 📦 비유:  
> 패키지는 **문서철 폴더**,  
> 클래스는 그 안에 있는 **문서 한 장**이야!

---

## 5️⃣ 가비지 컬렉션 개념

- JVM이 **사용하지 않는 객체(가비지)**를 자동으로 회수함
- `System.gc()` 또는 `Runtime.getRuntime().gc()`로 수동 요청 가능

> 🧹 비유:  
> 안 쓰는 변수는 **쓰레기**,  
> 가비지 컬렉터는 **청소부**!

---

## 6️⃣ 가비지 발생 예시

```java
String a = new String("Good");
a = null; // "Good"은 가비지 발생



Person a = new Person("홍길동");
Person b = new Person("이몽룡");
b = a; // 이전 b가 가리키던 객체는 가비지

🪙 비유:
b가 새 장난감을 사면서 예전 장난감은 버림받은 상태!
```
# 📘 자바 접근 지정자, static 멤버, 가비지 컬렉션 정리

## 1️⃣ 멤버 접근 지정자

| 접근 지정자 | 같은 패키지 | 다른 패키지 | 상속 관계 | 설명 |
|-------------|--------------|--------------|------------|------|
| `private`   | ❌           | ❌           | ❌         | 같은 클래스 내부에서만 접근 가능 |
| `default`   | ⭕           | ❌           | ❌         | 같은 패키지 내의 클래스만 접근 가능 |
| `protected` | ⭕           | ❌           | ⭕         | 같은 패키지 + 다른 패키지 자식 클래스도 접근 가능 |
| `public`    | ⭕           | ⭕           | ⭕         | 모든 클래스에서 접근 가능 |

> 📌 비유:  
> `private`는 **집 비밀번호**,  
> `default`는 **우리 아파트 주민 전용**,  
> `protected`는 **친척들까지 들어올 수 있음**,  
> `public`은 **누구든 환영하는 오픈 행사** 느낌이야!

---

## 2️⃣ 클래스 접근 지정자

- `public` 클래스: 모든 패키지에서 접근 가능  
- `default` 클래스: 같은 패키지에서만 접근 가능  

> 🏠 비유:  
> `public class`는 누구나 들어올 수 있는 **오픈 카페**,  
> `default class`는 아파트 **입주민 전용 커뮤니티 센터**!

---

## 3️⃣ 접근 지정자의 목적

- **객체지향의 캡슐화** 원칙을 지키기 위해 멤버 접근을 제어함
- 정보를 숨기고 필요한 것만 외부에 공개하도록 함

> 🔐 비유:  
> 클래스는 **비밀 금고**,  
> 접근 지정자는 **열쇠 권한**을 관리하는 느낌!

---

## 4️⃣ 자바의 패키지 개념

- 관련된 클래스들을 묶는 **폴더(디렉토리)**
- 하나의 자바 응용프로그램은 여러 개의 패키지로 구성됨

> 📦 비유:  
> 패키지는 **문서철 폴더**,  
> 클래스는 그 안에 있는 **문서 한 장**이야!

---

## 5️⃣ 가비지 컬렉션 개념

- JVM이 **사용하지 않는 객체(가비지)**를 자동으로 회수함
- `System.gc()` 또는 `Runtime.getRuntime().gc()`로 수동 요청 가능

> 🧹 비유:  
> 안 쓰는 변수는 **쓰레기**,  
> 가비지 컬렉터는 **청소부**!

---

## 6️⃣ 가비지 발생 예시

```java
String a = new String("Good");
a = null; // "Good"은 가비지 발생
```

> 📉 참조가 사라지는 순간, 힙 메모리 안의 객체는 가비지!

---

## 7️⃣ 가비지 예제 (레퍼런스 교체)

```java
Person a = new Person("홍길동");
Person b = new Person("이몽룡");
b = a; // 이전 b가 가리키던 객체는 가비지
```

> 🪙 비유:  
> b가 새 장난감을 사면서 예전 장난감은 **버림받은 상태**!

---

## 8️⃣ 객체 소멸 개념

- `new`로 만든 객체는 **JVM의 힙**에 저장됨
- 더 이상 사용하지 않으면 GC가 회수

> 🚮 자바는 쓰레기 버리는 걸 **직접 안 해도 되는 편리함**이 있어

---

## 9️⃣ 객체 치환 시 주의

```java
ob1 = ob2; // ob1이 가리키던 객체는 더 이상 접근 불가 → 가비지
```

> 🎯 복사는 내용이 아니라 **참조(화살표)**가 바뀌는 거야!

---

## 🔟 오버로딩 실패 예시

```java
public int getSum(int i, int j) { ... }
public double getSum(int i, int j) { ... } // ❌ 실패
```

> ⚠️ 매개변수의 개수나 타입이 달라야 오버로딩 성공!

---

## 1️⃣1️⃣ static 메서드 예제

```java
public class Calc {
    public static int abs(int a) { return a > 0 ? a : -a; }
    public static int max(int a, int b) { return a > b ? a : b; }
    public static int min(int a, int b) { return a > b ? b : a; }
}
```

> 🧮 전역 유틸 클래스의 대표적인 예: `Math.abs()`, `Math.max()` 처럼 사용!

---

## 1️⃣2️⃣ static 메서드 제약 조건

- static 메서드는 **static 멤버만 접근 가능**
- 객체 생성 없이 실행되므로 non-static 멤버는 사용 불가

> 🧱 비유:  
> 건물 설계도만 있는 상태에선 **내부 가구 배치(객체 멤버)**는 접근 불가!

---

## 1️⃣3️⃣ static의 활용

- **전역 변수 / 전역 함수** 느낌
- **공통 속성 또는 기능** 정의 시 사용

---

## 1️⃣4️⃣ static 멤버 생성

- 클래스당 **하나만 생성됨**
- 모든 객체가 공유

> 👥 비유:  
> 학교 전체가 공유하는 **학칙**,  
> 반마다 있는 건 아님!

---


## 1️⃣5️⃣ static 멤버 사용 방법

- 클래스 이름으로 직접 접근
```java
StaticSample.m = 5;
StaticSample.f();
```
- 객체 이름으로도 접근 가능
```java
obj.m = 5;
obj.f();
```

---

## 1️⃣6️⃣ non-static 멤버 접근 불가 예시

```java
StaticSample.n = 5; // ❌ 오류
StaticSample.g();   // ❌ 오류
```

> ❗ 객체가 생성되어야 사용할 수 있음!

---

## 1️⃣7️⃣ static vs non-static 차이

| 특성 | non-static | static |
|------|------------|--------|
| 생성 시점 | 객체 생성 시 | 클래스 로딩 시 |
| 생성 수 | 객체마다 별도 | 클래스당 1개 |
| 메모리 위치 | 힙 영역 | 메서드 영역 |
| 공유 여부 | ❌ | ⭕ |

---

## 1️⃣8️⃣ static 멤버는 언제 생성?

- 객체 없이도 생성됨  
- 모든 객체가 같은 static 멤버를 공유

---

## 1️⃣9️⃣ static 멤버 선언 예시

```java
class StaticSample {
    static int m;
    static void f() { ... }
}
```

---

## 2️⃣0️⃣ 접근 지정자 예제

```java
class Sample {
    public int a;
    private int b;
    int c; // default
}

public class AccessEx {
    public static void main(String[] args) {
        Sample s = new Sample();
        s.a = 10; // ⭕
        s.b = 10; // ❌ private
        s.c = 10; // ⭕ default (같은 패키지)
    }
}
```


# 📘5월 8일 자바 수업 정리

## 추상 클래스와 추상 메서드 정리

### 추상 메서드 (abstract method)

- `abstract`로 선언된 메서드는 **구현부 없이 선언만 존재**함.
- 즉, **"무엇을 해야 하는지"만 알려주고, "어떻게 할지"는 자식 클래스에서 정함**.

```java
abstract public String getName(); // ✅ 추상 메서드 (정상)

abstract public String fail() {
    return "Good Bye";
} 
// ❌ 오류: 추상 메서드는 본문(구현부)을 가지면 안 됨


# 📘 추상 클래스의 상속과 구현

---

## ✅ 1. 추상 클래스 상속

- 추상 클래스는 메서드의 **구현 없이 선언만 있는 상태**를 의미함.
- 추상 클래스를 상속하면, 자식 클래스도 **추상 클래스가 되어야 함**.
- 추상 클래스는 **인스턴스를 생성할 수 없음**.

```java
abstract class A {  // 추상 클래스
    abstract public int add(int x, int y); // 추상 메서드
}

abstract class B extends A {  // 추상 클래스
    public void show() {
        System.out.println("B");
    }
}

// 아래는 컴파일 오류!
A a = new A(); // ❌ 오류: 추상 클래스는 인스턴스 생성 불가
B b = new B(); // ❌ 오류: 추상 클래스는 인스턴스 생성 불가

# 📘 추상 클래스의 상속과 구현 정리

---

## ✅ 추상 클래스 상속

- 추상 클래스를 상속받으면 **서브 클래스도 abstract여야 함**
- 이유: **추상 메서드를 구현하지 않았기 때문**
- 추상 클래스는 **불완전한 설계도**이기 때문에 **인스턴스를 직접 만들 수 없음**

### 🔧 예시 코드

```java
abstract class A {
    abstract public int add(int x, int y); // 추상 메서드
}

abstract class B extends A {
    public void show() { System.out.println("B"); }
}

---

# 📘 자바 인터페이스 정리

## ✅ 자바에서 인터페이스란?

- 소프트웨어를 **모듈화**하고, 표준 규격(인터페이스)을 통해 **호환성과 확장성**을 확보하기 위해 사용됨.
- 마치 **콘센트와 전기기기**처럼, **정해진 인터페이스(규격)에 맞춰 연결되도록** 하기 위함.

> 🔌 비유:  
> 콘센트(인터페이스)에 꽂을 수 있는 다양한 전자기기들처럼, 인터페이스에 맞추면 어떤 클래스든 동작 가능!

---

## ✅ 인터페이스의 구성 요소

```java
interface PhoneInterface {
    public static final int TIMEOUT = 10000;     // 상수 필드
    public abstract void sendCall();            // 추상 메서드
    public abstract void receiveCall();         // 추상 메서드
    public default void printLogo() {           // default 메서드
        System.out.println("** Phone **");
    }
}
```

| 구성 요소               | 설명 |
|------------------------|------|
| `public static final`  | 상수 필드. 자동으로 붙음 |
| `public abstract`      | 추상 메서드. 자동으로 붙음 |
| `default`              | 구현된 메서드 (Java 8부터) |

---

## ✅ 자바 인터페이스의 변화

| Java 버전 | 변화 내용 |
|-----------|-----------|
| Java 7 이하 | 오직 상수 필드 + 추상 메서드만 허용 |
| Java 8     | `default` 메서드 추가 (구현 포함 허용) |
| Java 9     | `private`, `static` 메서드 허용됨 |
| 여전히     | **멤버 변수 선언 불가** (필드는 무조건 상수로 고정됨)

---

## ✅ 정리

- 인터페이스는 **규칙**이다. → 구현 클래스는 이 규칙을 **강제로 따라야 함**
- **`implements` 키워드**로 클래스에서 인터페이스를 구현
- 하나의 클래스가 **여러 인터페이스 구현 가능** (다중 구현)

> 🧩 비유:  
> 인터페이스는 전자제품의 **콘센트 규격**!  
> 클래스는 그 규격에 맞춘 **제품**이야!

## 📘 인터페이스 구현과 상속 – 추가 정리

---

### ✅ 인터페이스 구현 (`implements` 키워드)

- 인터페이스의 **추상 메서드를 모두 구현**한 클래스를 작성할 수 있음
- 이때 `implements` 키워드를 사용
- **여러 개의 인터페이스도 동시에 구현 가능**

```java
class SamsungPhone implements PhoneInterface {
    public void sendCall() {
        System.out.println("띠리리리링");
    }

    public void receiveCall() {
        System.out.println("전화가 왔습니다.");
    }

    // 추가 메서드 정의 가능
    public void flash() {
        System.out.println("전화기에 불이 켜졌습니다.");
    }
}
```

> 📌 이 클래스는 `PhoneInterface`의 모든 메서드를 구현했기 때문에 정상적인 구현 클래스가 됨.  
> 또한 `PhoneInterface`의 `default` 메서드도 **자동 상속**됨.

---

### ✅ 인터페이스 간의 상속 (`extends` 키워드)

- **인터페이스도 다른 인터페이스를 상속**할 수 있음
- 이때는 `extends` 키워드를 사용하며, **기능 확장이 목적**
- 클래스와 달리, **여러 인터페이스를 동시에 상속 가능** (다중 상속 허용)

```java
// 단일 상속
interface MobilePhoneInterface extends PhoneInterface {
    void sendSMS();
    void receiveSMS();
}

// 다중 상속
interface MusicPhoneInterface extends PhoneInterface, MP3Interface {
    // 여러 인터페이스 기능을 조합
}
```

> 📌 클래스에서는 다중 상속이 불가능하지만, **인터페이스는 다중 상속 가능**한 것이 큰 차이점!
